# The Flyway Teamworks Scriptblocks.

These are a collection of script blocks that are designed to run with Flyway either in the community edition or with Teams. They allow you to maintain backups or scripts for each version and make a Flyway a full participant in any source control system in use, even to the point of providing an  object-level source to allow the evolution of individual tables to be tracked.

Some of these will work on the major relational database systems, whereas some are for SQL Server only 

A simple database that is really nothing more than a grown-up spreadsheet will  not need any of this fancy stuff. It becomes increasingly important as the database grows into a team effort. The facilities cover automatic code reviews, source control, and change tracking. It provides build scripts that are, I believe, essential to successful branching and merging, and for databases such as MySQL that do not roll-back DDL changes in failed transactions. Some of these utilities are there primarily to show how to run external programs, or to save the results of a SQL Call as a JSON file or other result. I have  examples of SQL Code executed from a variable containing a query,  and from  a file. 

They share a common data object (hashtable) as a parameter. This is automatically  generated by the preliminary.ps1 that also obligingly retrieves your password from your local secure store. This hashtable has all the parameters set by the config  files and environment variables. It parses the URL provided to Flyway to retrieve the name of the database server, port and the database. Each scriptblock checks to see whether you've provided what is needed... the parameter is actually a hashTable passed by reference. 
Few of these parameters  are needed for any one task, and some such as version and password are filled in as the hashtable is accessed.

These Scriptblocks can be batched up into an array and processed one by one. Some of them are utility chores such as extracting passwords from a relatively safe place, or fetching prepared parameters. There
is one that merely formats the data. They are able to write errors or status to the data object. The hashtable is passed by reference. One has to be cautious with this because alterations to the hashtable can result in powerShell holding a copy instead. 

As well as being run in a series, they can be used individually. If one of them needs maintenance, it is very easy to pull it apart and run it interactively.

The reason for using this design was to make it easy to choose what gets run and in what order. 

**$CheckCodeInDatabase** *(SQL Server only)*
This scriptblock checks the code in the database for any issues, using SQL Code Guard to do all the work. This runs SQL Codeguard  and saves the report in a subdirectory the version directory of your project artefacts. It also reports back in the **$dbDetails** Hashtable. It checks the current database, not the scripts

**$CheckCodeInMigrationFiles** *(SQL Server only)*
This scriptblock checks the code in the migration files for any issues, using SQL Code Guard to do all the work. This runs SQL Codeguard and saves the report in a subdirectory the version directory of your 
project artefacts. It also reports back in the **$dbDetails** Hashtable. It checks the scripts not the current database.

**$CreateScriptFoldersIfNecessary**: *(SQL Server, Oracle, SQLite, MySQL, MariaDB, PostgreSQL)*
this task checks to see if a Source folder already exists for this version of the database and, if not, it will create one and fill it with subdirectories for each type of object. A tables folder will, for example, have a file for every table each containing a build script to create that object. When this exists, it allows SQL Compare
to do comparisons and check that a version has not drifted. It saves the Source folder as a subfolder for the supplied version, so it needs **$GetCurrentVersion** to have been run beforehand in the chain of tasks.

**$CreateBuildScriptIfNecessary**: *(PostgreSQL, MySQL, MariaDB,SQL Server, SQLite)*
produces a build script from the database, using SQL Compare. It saves the build script in the Scripts folder, as a subfolder for the supplied version, so it needs $GetCurrentVersion to have been run beforehand in the chain of tasks.

**$ExecuteTableSmellReport** *(SQL Server only)*
This scriptblock executes SQL that produces a report in XML or JSON from the database that alerts you to tables that may have issues

**$ExecuteTableDocumentationReport** *(SQL Server,MySQL, MariaDB, PosgreSQL)*
 This places in a report a json report of the documentation of every table and its columns. If you add or change tables, this can be subsequently used to update the **AfterMigrate** callback script
for the documentation. 

**$FetchAnyRequiredPasswords** *(all RDBMSs)*
This checks the hash table to see if there is a username without a password. If so, the task asks for it in a query window and stores it, encrypted, in the user area it. If the user already has the password stored for this username and database, it uses it.

**$ExecuteTableSmellReport** *(SQL Server only)*
This scriptblock executes SQL that produces a report in XML or JSON from the database

**$GetCurrentVersion** *(PostgreSQL, Oracle, MySQL, MariaDB,SQL Server, SQLite)*
This contacts the database and determines its current version, and previous version by interrogating the flyway_schema_history data table in the database. If it is an empty database,or there is just no Flyway data, then it returns a version of 0.0.0.

**$GetCurrentServerVersion** *(PostgreSQL, Oracle, MySQL, MariaDB,SQL Server, SQLite)*
This scriptblock gets the current version of the RDBMS on the server and is used mainly to check that the migration doesn't use any functionality that can't be supported on that server version. It updates
the $dbDetails.ServerVersion 

**$IsDatabaseIdenticalToSource:** *(SQL Server only)*
This uses SQL Compare to check that a version of a database is correct and hasn't been changed. To do this, the $CreateScriptFoldersIfNecessary task must have been run first. It compares the database to the associated source folder, for that version, and returns, in the hash table, the comparison equal to true if it was the same, or false if there has been drift, with a list of objects that have changed. If the comparison returns $null, then it means there has been an error. To access the right source folder for this database version, it needs $GetCurrentVersion to have been run beforehand in the chain of tasks

**$SaveDatabaseModelIfNecessary** *(PostgreSQL,  Oracle, MySQL, MariaDB,SQL Server, SQLite)*
This writes a JSON model of the database to a file that can be used subsequently to check for database version-drift or to create a narrative of changes for the flyway project between versions.

**$BulkCopyIn** *(SQL Server only)*
This script performs a bulk copy operation to get data into a database. It can only do this if the data is in a suitable directory. At the moment it assumes that you are using a DATA directory at the same level as the scripts directory. 
BCP must have been previously installed in the path Unlike many other tasks, you are unlikely to want to do this more than once for any database.If you did, you'd need to clear out the existing data first! It is intended
for static scripts AKA baseline migrations.

**$BulkCopyout** *(SQL Server only)*
This script performs a bulk copy operation to get data out of a database, and into a suitable directory. At the moment it assumes that you wish to use a DATA directory at the same level as the scripts directory. 
BCP must have been previously installed in the path.

**$CreateUndoScriptIfNecessary** *(SQL Server only)*
this creates a first-cut UNDO script for the metadata (not the data) which can be adjusted and modified quickly to produce an UNDO Script. It does this by using SQL Compare to generate a  idepotentic script comparing the database with the  contents of the previous version.

**$GeneratePUMLforGanttChart** *(All RDBMSs)*
This script creates a PUML file for a Gantt chart at the current version of the database. This can be read into any editor that takes PlantUML files to give a Gantt chart

**$CreatePossibleMigrationScript** *(SQL Server only)*
This creates a forward migration that scripts out all the changes made to the database since the current migration

**$SaveFlywaySchemaHistoryIfNecessary** *(all RDBMSs)*
This reads the flyway history table, and uses the information to annotate the directories containing the various reports and scripts for that version

**$CreateVersionNarrativeIfNecessary** *(PostgreSQL, Oracle, MySQL, MariaDB, SQL Server, SQLite)*
This aims to tell you what has changed between each version of the database. 

**$WriteOutERDiagramCode** *(PostgreSQL,  Oracle, MySQL, MariaDB, SQL Server, SQLite)*
This creates a simple entity diagram for the current version. You only need two files to do this and you don't need to contact the database. The ER diagram has all objects that are either added, removed or changed colour-coded so you can see immediately what has changed. The idea of this is to be able to paste the resulting SVG file or other image file of the diagram, produced by PlantUMLc.exe.

**$CheckFluffInPendingFiles** *(PostgreSQL,  Oracle, MySQL, MariaDB, SQL Server, SQLite)*
This scriptblock checks the code in the pending files for any issues,using SQL Fluff to do all the work. It saves the report in a subdirectory 
of the version directory of your project artefacts. It also reports back in the $DatabaseDetails Hashtable. 

**$DoesTheFlywayTableExist** *(PostgreSQL,  Oracle, MySQL, MariaDB, SQL Server, SQLite)* 
This checks to see if there is a flyway schema table 
in the database. It sets a value in the dbDetails object (FlywayTableExists) that is true or false.

**$ExtractFromSQLServerIfNecessary** *(SQL Server only)*
This connects to the SQL Server database and will then, For the current version of the database extract either a 
 - *'DacPac'*     (output a .dacpac single file). 
 - *'Flat'*  (all files in a single folder),
 - *'SchemaObjectType'* (files in folders for each schema and object type), 
 - *'Schema'* (files in folders for each schema),
 - *'ObjectType'*  (files in folders for each object type), 'Flat' (all files in the same folder)
 - *'File'* (1 single file). 
## examples of usage

Tasks can be executed one at a time or stacked up and executed one after another. 
### Simple Arms-length usage
In the framework, you'd have a $dbDetails object to store what can become a huge number of parameters, especially if you really like your placeholders. Lets start without doing that, just to demonstrate that it is possible to just run the tasks you want without getting in too deep.

```
Process-FlywayTasks @{
   'version'='1.1.5'; 'server'='MyServer'; 'reportLocation'=MyDirectory; 
   'database'=' MyDatabase '; 'pwd'='mySecretPassword'; 'uid'='MyUserID';
   'project'='Pubs'; 'projectDescription'='A simple Demonstration';
   'problems'=@{};'warnings'=@{};'feedback'=@{};'writeLocations'=@{}
} $ExtractFromSQLServerIfNecessary 
```
### Using the shared DbDetails object.
However if you are using the preliminary.ps1 to keep your stash of parameters in a shared $DBDetails object, it is all simpler and neater.

Here are several tasks being done together 

```
`$PostMigrationTasks = @(`
	`$GetCurrentVersion, #checks the database and gets the current version number`
	`#it does this by reading the Flyway schema history table.` 
    `$GetCurrentServerVersion, #get the current version of the database server`
	`$CreateBuildScriptIfNecessary, #Create a build script for the database in a` 
	`#subdirectory for this version.`
	`$SaveDatabaseModelIfNecessary, #Build a JSON model of the database that we can`
	`#later use for comparing versions to create a chronicle of changes.`
	`$CreateVersionNarrativeIfNecessary,`
    `#save the information from the history table about when all the changes were made and by whom
‹    `$SaveFlywaySchemaHistoryIfNecessary`
`)`
`Process-FlywayTasks $dbDetails $PostMigrationTasks`
‹	`}`
`}`
```

here is one scriptblock being done

``` 
Process-FlywayTasks $dbDetails $GetCurrentServerVersion 
```

Some scriptblocks have extra parameters that allow them to be used more freely. 

here is an ERD diagram being done for a different version of the current project

``` 
Process-FlywayTasks $dbDetails $WriteOutERDiagramCode @('1.1.6')
```

In this case, there are other parameters that can be changed but they are ignored if set to NULL

```
Process-FlywayTasks $dbDetails $WriteOutERDiagramCode @(
		'1.1.7', #version - the flyway version of the database. Leave null if using framework
		  $null, #Title - the flyway project. Leave null if using framework
          $null, #FileLocations - where to store all files
		  $null, #MetadatachangeFile - Specify if not using the default location
		  $null, #modelFile - Specify if not using the default location
		  $null  #MyPUMLFile - The path to the PUML file
)
```

Here we change the title and the location of the files

```
Process-FlywayTasks @{
problems=@{};warnings=@{};feedback=@{};writeLocations=@{}
} $WriteOutERDiagramCode @(
		'1.1.7', #version - the flyway version of the database. Leave null if using framework
		'MyTitle', #Title - the flyway project. Leave null if using framework
        'MyFileLocation', #FileLocations - where to store all files
		$null, #MetadatachangeFile - Specify if not using the default location
		$null, #modelFile - Specify if not using the default location
		$null  #MyPUMLFile - The path to the PUML file
);Process-FlywayTasks $dbDetails $WriteOutERDiagramCode @('1.1.6')
```

You might not want all the project array because you're just generating diagrams from the two model files. Why not? So you just do the bare minimum hashtable

```
`Process-FlywayTasks @{`
`problems=@{};warnings=@{};feedback=@{};writeLocations=@{}`
`} $WriteOutERDiagramCode @(`
		`'1.1.7', #version - the flyway version of the database. Leave null if using framework`
		`'MyTitle', #Title - the flyway project. Leave null if using framework`
        `'MyFileLocation', #FileLocations - where to store all files`
		`$null, #MetadatachangeFile - Specify if not using the default location`
		`$null, #modelFile - Specify if not using the default location`
		`$null  #MyPUMLFile - The path to the PUML file`
`);`
```

To set off any task, all you need is a PowerShell script that is created in such a way that it can be executed by Flyway when it finishes a migration run. Although you can choose any of the significant points in any Flyway action, there are only one or two of these callback points that are useful to us.  

This can be a problem if you have several chores that need to be done in the same callback or you have a stack of scripts all on the same callback, each having to gather up and process parameters, or pass parameters such as the current version from one to another. 

A callback script can’t be debugged as easily as an ordinary script. In this design, the actual callback just executes a list of tasks in order, and you simply add a task to the list after you’ve debugged and tested it & placed in the DatabaseBuildAndMigrateTasks.ps1 file.
with just one callback script

Each task is passed a standard ‘parameters’ object. This keeps the ‘complexity beast’ snarling in its lair.
The parameter object is passed by reference so each task can add value to the data in the object, such as passwords, version number, errors, warnings and log entries. 

All parameters are passed by Flyway. It does so by environment variables that are visible to the script.
You can access these directly, and this is probably best for tasks that require special informationpassed by custom placeholders, such as the version of the RDBMS, or the current variant of the version  you're building

### Getting the $dbDetails object and all its values

The ". '.\preliminary.ps1" line - that this callback startes with - creates a DBDetails array.
You can dump this array for debugging so that it is displayed by Flyway

   `$DBDetails|convertTo`-json

these routines return the path they write to in the $DbDetails if you need it.
You will also need to set the paths to the various commandline utilities to the correct value. 
For SQLCMD, for example, this is set by a string that is read from MyToolLocations.ps1 in your Flyway Teamwork directory. 
it can be set as a default in the resources directory in the toolLocations.ps1 file in the RESOURCES  directory 

### Using a callback script
Here is a worked example, with the tasks you want to execute. Some, like the on getting credentials, are essential before you execute others.
In order to execute tasks, you just load them up in the order you want. It is like loading a revolver.

``` 
. '.\preliminary.ps1'

$PostMigrationTasks = @(
	$GetCurrentVersion, #checks the database and gets the current version number
    #it does this by reading the Flyway schema history table. 
	$CreateBuildScriptIfNecessary, #writes out a build script if there isn't one for this version. This
    #uses SQL Compare
	$CreateScriptFoldersIfNecessary, #writes out a source folder with an object level script if absent.
    #this uses SQL Compare
	$ExecuteTableSmellReport, #checks for table-smells
    #This is an example of generating a SQL-based report
	$ExecuteTableDocumentationReport, #publishes table docuentation as a json file that allows you to
    #fill in missing documentation. 
	$CheckCodeInDatabase, #does a code analysis of the code in the live database in its current version
    #This uses SQL Codeguard to do this
	$CheckCodeInMigrationFiles, #does a code analysis of the code in the migration script
    #This uses SQL Codeguard to do this
	$IsDatabaseIdenticalToSource, # uses SQL Compare to check that a version of a database is correct
    #this makes sure that the target is at the version you think it is.
    $SaveDatabaseModelIfNecessary #writes out the database model
    #This writes out a model of the version for purposes of comparison, narrative and checking. 
    $CreateUndoScriptIfNecessary # uses SQL Compare
    #Creates a first-cut UNDo script. This is an idempotentic script that undoes to the previous version 
    $GeneratePUMLforGanttChart
    # This script creates a PUML file for a Gantt chart at the current version of the 
    #database. This can be read into any editor that takes PlantUML files to give a Gantt
    #chart 
            )
Process-FlywayTasks $DBDetails $PostMigrationTasks
```
Yeah, a lot of work is being done without you getting overwhelmed by the details and complexity