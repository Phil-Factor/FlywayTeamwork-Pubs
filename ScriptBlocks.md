



# The Flyway Teamworks Scriptblocks.

These are a collection of script blocks that are designed to run with Flyway either in the community edition or with Teams. They allow you to maintain backups or scripts for each version and make a Flyway a full participant in any source control system in use, even to the point of providing an  object-level source to allow the evolution of individual tables to be tracked.

Some of these will work on the major relational database systems, whereas some are for SQL Server only 

A simple database that is really nothing more than a grown-up spreadsheet will  not need any of this fancy stuff. It becomes increasingly important as the database grows into a team effort. The facilities cover automatic code reviews, source control, and change tracking. It provides build scripts that are, I believe, essential to successful branching and merging, and for databases such as MySQL that do not roll-back DDL changes in failed transactions. Some of these utilities are there primarily to show how to run external programs, or to save the results of a SQL Call as a JSON file or other result. I have  examples of SQL Code executed from a variable containing a query,  and from  a file. 

They share a common data object (hashtable) as a parameter. This is automatically  generated by the preliminary.ps1 that also obligingly retrieves your password from your local secure store. This hashtable has all the parameters set by the config  files and environment variables. It parses the URL provided to Flyway to retrieve the name of the database server, port and the database. Each scriptblock checks to see whether you've provided what is needed... the parameter is actually a hashTable passed by reference. 
Few of these parameters  are needed for any one task, and some such as version and password are filled in as the hashtable is accessed.

These Scriptblocks can be batched up into an array and processed one by one. Some of them are utility chores such as extracting passwords from a relatively safe place, or fetching prepared parameters. There
is one that merely formats the data. They are able to write errors or status to the data object. The hashtable is passed by reference. One has to be cautious with this because alterations to the hashtable can result in powerShell holding a copy instead. 

As well as being run in a series, they can be used individually. If one of them needs maintenance, it is very easy to pull it apart and run it interactively.

The reason for using this design was to make it easy to choose what gets run and in what order. 

**$CheckCodeInDatabase** *(SQL Server only)*
This scriptblock checks the code in the database for any issues, using SQL Code Guard to do all the work. This runs SQL Codeguard  and saves the report in a subdirectory the version directory of your project artefacts. It also reports back in the **$DBDetails** Hashtable. It checks the current database, not the scripts

**$CheckCodeInMigrationFiles** *(SQL Server only)*
This scriptblock checks the code in the migration files for any issues, using SQL Code Guard to do all the work. This runs SQL Codeguard and saves the report in a subdirectory the version directory of your 
project artefacts. It also reports back in the **$DBDetails** Hashtable. It checks the scripts not the current database.

**$CreateScriptFoldersIfNecessary**: *(SQL Server only)*
this task checks to see if a Source folder already exists for this version of the database and, if not, it will create one and fill it with subdirectories for each type of object. A tables folder will, for example, have a file for every table each containing a build script to create that object. When this exists, it allows SQL Compare
to do comparisons and check that a version has not drifted. It saves the Source folder as a subfolder for the supplied version, so it needs **$GetCurrentVersion** to have been run beforehand in the chain of tasks.

**$CreateBuildScriptIfNecessary**: *(PostgreSQL, MySQL, MariaDB,SQL Server, SQLite)*
produces a build script from the database, using SQL Compare. It saves the build script in the Scripts folder, as a subfolder for the supplied version, so it needs $GetCurrentVersion to have been run beforehand in the chain of tasks.

**$ExecuteTableSmellReport** *(SQL Server only)*
This scriptblock executes SQL that produces a report in XML or JSON from the database that alerts you to tables that may have issues

**$ExecuteTableDocumentationReport** *(SQL Server only)*
 This places in a report a json report of the documentation of every table and its columns. If you add or change tables, this can be subsequently used to update the **AfterMigrate** callback script
for the documentation. 

**$FetchAnyRequiredPasswords** *(all RDBMSs)*
This checks the hash table to see if there is a username without a password. If so, the task asks for it in a query window and stores it, encrypted, in the user area it. If the user already has the password stored for this username and database, it uses it.

**$ExecuteTableSmellReport** *(SQL Server only)*
This scriptblock executes SQL that produces a report in XML or JSON from the database

**$GetCurrentVersion** *(PostgreSQL, MySQL, MariaDB,SQL Server, SQLite)*
This contacts the database and determines its current version, and previous version by interrogating the flyway_schema_history data table in the database. If it is an empty database,or there is just no Flyway data, then it returns a version of 0.0.0.

**$GetCurrentServerVersion** *(PostgreSQL, MySQL, MariaDB,SQL Server, SQLite)*
This scriptblock gets the current version of the RDBMS on the server and is used mainly to check that the migration doesn't use any functionality that can't be supported on that server version. It updates
the $Param1.ServerVersion 

**$IsDatabaseIdenticalToSource:** *(SQL Server only)*
This uses SQL Compare to check that a version of a database is correct and hasn't been changed. To do this, the $CreateScriptFoldersIfNecessary task must have been run first. It compares the database to the associated source folder, for that version, and returns, in the hash table, the comparison equal to true if it was the same, or false if there has been drift, with a list of objects that have changed. If the comparison returns $null, then it means there has been an error. To access the right source folder for this database version, it needs $GetCurrentVersion to have been run beforehand in the chain of tasks

**$SaveDatabaseModelIfNecessary** *(PostgreSQL, MySQL, MariaDB,SQL Server, SQLite)*
This writes a JSON model of the database to a file that can be used subsequently to check for database version-drift or to create a narrative of changes for the flyway project between versions.

**$BulkCopyIn** *(SQL Server only)*
This script performs a bulk copy operation to get data into a database. It can only do this if the data is in a suitable directory. At the moment it assumes that you are using a DATA directory at the same level as the scripts directory. 
BCP must have been previously installed in the path Unlike many other tasks, you are unlikely to want to do this more than once for any database.If you did, you'd need to clear out the existing data first! It is intended
for static scripts AKA baseline migrations.

**$BulkCopyout** *(SQL Server only)*
This script performs a bulk copy operation to get data out of a database, and into a suitable directory. At the moment it assumes that you wish to use a DATA directory at the same level as the scripts directory. 
BCP must have been previously installed in the path.

**$CreateUndoScriptIfNecessary** *(SQL Server only)*
this creates a first-cut UNDO script for the metadata (not the data) which can be adjusted and modified quickly to produce an UNDO Script. It does this by using SQL Compare to generate a  idepotentic script comparing the database with the  contents of the previous version.

**$GeneratePUMLforGanttChart** *(All RDBMSs)*
This script creates a PUML file for a Gantt chart at the current version of the database. This can be read into any editor that takes PlantUML files to give a Gantt chart

**$CreatePossibleMigrationScript** *(SQL Server only)*
This creates a forward migration that scripts out all the changes made to the database since the current migration

**$SaveDatabaseModelIfNecessary** *(PostgreSQL, MySQL, MariaDB,SQL Server, SQLite)*
This writes a JSON model of the database to a file that can be used subsequently to check for database version-drift or to create a narrative of changes for the flyway project between versions. 

**$SaveFlywaySchemaHistoryIfNecessary** *(all RDBMSs)*
This reads the flyway history table, and uses the information to annotate the directories containing the various reports and scripts for that version

**$CreateVersionNarrativeIfNecessary** *(PostgreSQL, MySQL, MariaDB, SQL Server, SQLite)*
This aims to tell you what has changed between each version of the database. 