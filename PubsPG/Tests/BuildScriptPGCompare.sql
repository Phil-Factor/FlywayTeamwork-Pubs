-- Script generated by Redgate Compare v1.33.5.536
SET check_function_bodies = false;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating public.itexists...';END$$;
CREATE TABLE public.itexists (
    count bigint
);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating public.theyear(timestamp with time zone)...';END$$;
CREATE FUNCTION public.theyear(IN thedatetime timestamp with time zone)
RETURNS character
LANGUAGE plpgsql
AS $_$
begin
  return cast (EXTRACT(YEAR FROM TheDateTime) as Char(4));
end;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating public.theyear(timestamp without time zone)...';END$$;
CREATE FUNCTION public.theyear(IN thedatetime timestamp without time zone)
RETURNS character
LANGUAGE plpgsql
AS $_$
begin
  return cast (EXTRACT(YEAR FROM TheDateTime) as Char(4));
end;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating public.theyear(date)...';END$$;
CREATE FUNCTION public.theyear(IN thedatetime date)
RETURNS character
LANGUAGE plpgsql
AS $_$
begin
  return cast (EXTRACT(YEAR FROM TheDateTime) as Char(4));
end;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating public.check_postgresql_version(integer)...';END$$;
CREATE FUNCTION public.check_postgresql_version(IN min_version integer)
RETURNS void
LANGUAGE plpgsql
AS $_$
DECLARE
  version_num INTEGER;
BEGIN
  version_num := current_setting('server_version_num')::integer;

  IF version_num < min_version THEN
    RAISE EXCEPTION 'PostgreSQL version % or higher is required.', min_version;
  ELSE
    RAISE NOTICE 'PostgreSQL version: %', version_num;
  END IF;
END;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating public.check_postgresql_version()...';END$$;
CREATE FUNCTION public.check_postgresql_version()
RETURNS void
LANGUAGE plpgsql
AS $_$
/**
Summary: >
This function uses the current_setting('server_version_num')
function to retrieve the version of the PostgreSQL server 
as an integer. It then compares it to the figure (e.g. 13, 14, 15)
provided in the placeholder.
If the server version is less than  figure provided in the placeholder,
it raises an exception with the specified error message.

Author: Phil Factor
Date: Monday, 12 June 2023
Database: PubsDev
Returns: >
  Error if server version is too old
**/

BEGIN
  IF current_setting('server_version_num')::integer < 50000 THEN
    RAISE EXCEPTION 'Sorry, but PostgreSQL version 5.0 or higher is required.';
  END IF;


END;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating public.calculate_monthly_sales(character varying, character, character)...';END$$;
CREATE FUNCTION public.calculate_monthly_sales(IN title_id character varying DEFAULT '%'::character varying, IN start_year character DEFAULT '2000'::bpchar, IN end_year character DEFAULT NULL::bpchar)
RETURNS TABLE(date_char character, january integer, february integer, march integer, april integer, may integer, june integer, july integer, august integer, september integer, october integer, november integer, december integer, total integer)
LANGUAGE plpgsql
AS $_$
DECLARE
    endyear char(4);
BEGIN
    endyear := COALESCE(end_year, to_char(CURRENT_DATE, 'YYYY'));

    RETURN QUERY
    SELECT
        to_char(ord_date, 'YYYY') AS date_char,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 1 THEN qty ELSE 0 END) AS january,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 2 THEN qty ELSE 0 END) AS february,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 3 THEN qty ELSE 0 END) AS march,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 4 THEN qty ELSE 0 END) AS april,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 5 THEN qty ELSE 0 END) AS may,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 6 THEN qty ELSE 0 END) AS june,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 7 THEN qty ELSE 0 END) AS july,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 8 THEN qty ELSE 0 END) AS august,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 9 THEN qty ELSE 0 END) AS september,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 10 THEN qty ELSE 0 END) AS october,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 11 THEN qty ELSE 0 END) AS november,
        SUM(CASE WHEN EXTRACT(MONTH FROM ord_date) = 12 THEN qty ELSE 0 END) AS december,
        SUM(qty) AS total
    FROM
        sales
    WHERE
        title_id LIKE title_id
        AND EXTRACT(YEAR FROM ord_date) BETWEEN start_year AND endyear
    GROUP BY
        to_char(ord_date, 'YYYY');
END;
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people...';END$$;
CREATE SCHEMA people;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.phonetype...';END$$;
CREATE TABLE people.phonetype (
    typeofphone character varying(40) NOT NULL,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.phonetype ADD CONSTRAINT phonetypepk PRIMARY KEY (typeofphone);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.organisation...';END$$;
CREATE TABLE people.organisation (
    organisation_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    organisationname character varying(100) NOT NULL,
    lineofbusiness character varying(100) NOT NULL,
    legacyidentifier character varying(30),
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.organisation ADD CONSTRAINT organisationidpk PRIMARY KEY (organisation_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.noteperson...';END$$;
CREATE TABLE people.noteperson (
    noteperson_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    person_id integer NOT NULL,
    note_id integer NOT NULL,
    insertiondate timestamp without time zone NOT NULL DEFAULT now(),
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.noteperson ADD CONSTRAINT notepersonpk PRIMARY KEY (noteperson_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.location...';END$$;
CREATE TABLE people.location (
    location_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    organisation_id integer NOT NULL,
    address_id integer NOT NULL,
    typeofaddress character varying(40) NOT NULL,
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.location ADD CONSTRAINT locationpk PRIMARY KEY (location_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.addresstype...';END$$;
CREATE TABLE people.addresstype (
    typeofaddress character varying(40) NOT NULL,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.addresstype ADD CONSTRAINT typeofaddresspk PRIMARY KEY (typeofaddress);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.abode...';END$$;
CREATE TABLE people.abode (
    abode_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    person_id integer NOT NULL,
    address_id integer NOT NULL,
    typeofaddress character varying(40) NOT NULL,
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.abode ADD CONSTRAINT abodepk PRIMARY KEY (abode_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.location.location_typeofaddress_fkey...';END$$;
ALTER TABLE people.location ADD CONSTRAINT location_typeofaddress_fkey FOREIGN KEY (typeofaddress) REFERENCES people.addresstype (typeofaddress);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.location.location_organisation_id_fkey...';END$$;
ALTER TABLE people.location ADD CONSTRAINT location_organisation_id_fkey FOREIGN KEY (organisation_id) REFERENCES people.organisation (organisation_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.abode.abode_addresstypefk...';END$$;
ALTER TABLE people.abode ADD CONSTRAINT abode_addresstypefk FOREIGN KEY (typeofaddress) REFERENCES people.addresstype (typeofaddress);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.searchbyorganisationname...';END$$;
CREATE INDEX searchbyorganisationname ON people.organisation USING btree (organisationname);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.duplicateuk...';END$$;
ALTER TABLE people.noteperson ADD CONSTRAINT duplicateuk UNIQUE (person_id, note_id, insertiondate);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personaltitle...';END$$;
CREATE DOMAIN people.personaltitle AS character varying(10);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personalsuffix...';END$$;
CREATE DOMAIN people.personalsuffix AS character varying(10);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personalpostalcode...';END$$;
CREATE DOMAIN people.personalpostalcode AS character varying(15);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personalphonenumber...';END$$;
CREATE DOMAIN people.personalphonenumber AS character varying(20);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.phone...';END$$;
CREATE TABLE people.phone (
    phone_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    person_id integer NOT NULL,
    typeofphone character varying(40) NOT NULL,
    diallingnumber people.personalphonenumber NOT NULL,
    start_date timestamp without time zone NOT NULL,
    end_date timestamp without time zone,
    modifieddate timestamp without time zone DEFAULT now()
);
ALTER TABLE people.phone ADD CONSTRAINT phonepk PRIMARY KEY (phone_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.phone.phone_typeofphone_fkey...';END$$;
ALTER TABLE people.phone ADD CONSTRAINT phone_typeofphone_fkey FOREIGN KEY (typeofphone) REFERENCES people.phonetype (typeofphone);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personalpaymentcardnumber...';END$$;
CREATE DOMAIN people.personalpaymentcardnumber AS character varying;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personalnote...';END$$;
CREATE DOMAIN people.personalnote AS text;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.note...';END$$;
CREATE TABLE people.note (
    note_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    note people.personalnote NOT NULL,
    notestart character varying(900) GENERATED ALWAYS AS (COALESCE("left"((note)::text, 860), 'Blank'::text)) STORED,
    insertiondate timestamp without time zone NOT NULL DEFAULT now(),
    insertedby character varying(90) NOT NULL DEFAULT CURRENT_USER,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.note ADD CONSTRAINT notepk PRIMARY KEY (note_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.noteperson.noteperson_notefk...';END$$;
ALTER TABLE people.noteperson ADD CONSTRAINT noteperson_notefk FOREIGN KEY (note_id) REFERENCES people.note (note_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personalname...';END$$;
CREATE DOMAIN people.personalname AS character varying(40);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.person...';END$$;
CREATE TABLE people.person (
    person_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    title people.personaltitle,
    nickname people.personalname,
    firstname people.personalname NOT NULL,
    middlename people.personalname,
    lastname people.personalname NOT NULL,
    suffix people.personalsuffix,
    fullname character varying(80) GENERATED ALWAYS AS (((((COALESCE(((title)::text || ' '::text), ''::text) || (firstname)::text) || COALESCE((' '::text || (middlename)::text), ''::text)) || ' '::text) || (lastname)::text) || COALESCE((' '::text || (suffix)::text), ''::text)) STORED,
    legacyidentifier character varying(30),
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.person ADD CONSTRAINT personidpk PRIMARY KEY (person_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.phone.phone_person_id_fkey...';END$$;
ALTER TABLE people.phone ADD CONSTRAINT phone_person_id_fkey FOREIGN KEY (person_id) REFERENCES people.person (person_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.noteperson.noteperson_personfk...';END$$;
ALTER TABLE people.noteperson ADD CONSTRAINT noteperson_personfk FOREIGN KEY (person_id) REFERENCES people.person (person_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.abode.abode_personfk...';END$$;
ALTER TABLE people.abode ADD CONSTRAINT abode_personfk FOREIGN KEY (person_id) REFERENCES people.person (person_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.searchbypersonlastname...';END$$;
CREATE INDEX searchbypersonlastname ON people.person USING btree (lastname, firstname);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personallocation...';END$$;
CREATE DOMAIN people.personallocation AS character varying(20);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personalemailaddress...';END$$;
CREATE DOMAIN people.personalemailaddress AS character varying(40);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.emailaddress...';END$$;
CREATE TABLE people.emailaddress (
    emailid integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    person_id integer NOT NULL,
    emailaddress people.personalemailaddress NOT NULL,
    startdate date NOT NULL DEFAULT now(),
    enddate date,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.emailaddress ADD CONSTRAINT emailpk PRIMARY KEY (emailid);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.emailaddress.emailaddress_personfk...';END$$;
ALTER TABLE people.emailaddress ADD CONSTRAINT emailaddress_personfk FOREIGN KEY (person_id) REFERENCES people.person (person_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personalcvc...';END$$;
CREATE DOMAIN people.personalcvc AS character(3);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.creditcard...';END$$;
CREATE TABLE people.creditcard (
    creditcardid integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    person_id integer NOT NULL,
    cardnumber people.personalpaymentcardnumber NOT NULL,
    validfrom date NOT NULL,
    validto date NOT NULL,
    cvc people.personalcvc NOT NULL,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.creditcard ADD CONSTRAINT creditcardpk PRIMARY KEY (creditcardid);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.creditcard.creditcard_personfk...';END$$;
ALTER TABLE people.creditcard ADD CONSTRAINT creditcard_personfk FOREIGN KEY (person_id) REFERENCES people.person (person_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.duplicatecreditcarduk...';END$$;
ALTER TABLE people.creditcard ADD CONSTRAINT duplicatecreditcarduk UNIQUE (person_id, cardnumber);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.creditcardwasntunique...';END$$;
ALTER TABLE people.creditcard ADD CONSTRAINT creditcardwasntunique UNIQUE (cardnumber);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.personaladdressline...';END$$;
CREATE DOMAIN people.personaladdressline AS character varying(60);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.address...';END$$;
CREATE TABLE people.address (
    address_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY,
    addressline1 people.personaladdressline,
    addressline2 people.personaladdressline,
    city people.personallocation,
    region people.personallocation,
    postalcode people.personalpostalcode,
    country character varying(50),
    legacyidentifier character varying(30),
    full_address character varying(100) GENERATED ALWAYS AS ((((COALESCE((', '::text || (addressline1)::text), ''::text) || COALESCE((', '::text || (addressline2)::text), ''::text)) || COALESCE((', '::text || (city)::text), ''::text)) || COALESCE((', '::text || (region)::text), ''::text)) || COALESCE((', '::text || (postalcode)::text), ''::text)) STORED,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE people.address ADD CONSTRAINT addresspk PRIMARY KEY (address_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.publishers...';END$$;
CREATE VIEW people.publishers (pub_id, pub_name, city, state, country) AS SELECT replace((address.legacyidentifier)::text, 'pub-'::text, ''::text) AS pub_id,
    organisation.organisationname AS pub_name,
    address.city,
    address.region AS state,
    address.country
   FROM ((people.organisation
     JOIN people.location ON ((location.organisation_id = organisation.organisation_id)))
     JOIN people.address ON ((address.address_id = location.address_id)))
  WHERE (((organisation.lineofbusiness)::text = 'Publisher'::text) AND (location.end_date IS NULL));


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.authors...';END$$;
CREATE VIEW people.authors (au_id, au_lname, au_fname, phone, address, city, state, zip) AS SELECT replace((address.legacyidentifier)::text, 'au-'::text, ''::text) AS au_id,
    person.lastname AS au_lname,
    person.firstname AS au_fname,
    phone.diallingnumber AS phone,
    ((COALESCE((address.addressline1)::character varying, ''::character varying))::text || COALESCE((' '::text || (address.addressline2)::text), ''::text)) AS address,
    address.city,
    address.region AS state,
    address.postalcode AS zip
   FROM (((people.person
     JOIN people.abode ON ((abode.person_id = person.person_id)))
     JOIN people.address ON ((address.address_id = abode.address_id)))
     LEFT JOIN people.phone ON ((phone.person_id = person.person_id)))
  WHERE ((abode.end_date IS NULL) AND (phone.end_date IS NULL) AND ((person.legacyidentifier)::text ~~ 'au-%'::text));


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.location.location_address_id_fkey...';END$$;
ALTER TABLE people.location ADD CONSTRAINT location_address_id_fkey FOREIGN KEY (address_id) REFERENCES people.address (address_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating people.abode.abode_addressfk...';END$$;
ALTER TABLE people.abode ADD CONSTRAINT abode_addressfk FOREIGN KEY (address_id) REFERENCES people.address (address_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo...';END$$;
CREATE SCHEMA dbo;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.tagtitle...';END$$;
CREATE TABLE dbo.tagtitle (
    title_id character varying(6) NOT NULL,
    is_primary integer NOT NULL DEFAULT 0,
    tagname_id integer NOT NULL
);
ALTER TABLE dbo.tagtitle ADD CONSTRAINT tagtitle_pkey PRIMARY KEY (title_id, tagname_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.tagname...';END$$;
CREATE TABLE dbo.tagname (
    tagname_id integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    tag character varying(80) NOT NULL
);
ALTER TABLE dbo.tagname ADD CONSTRAINT tagname_pkey PRIMARY KEY (tagname_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.stores...';END$$;
CREATE TABLE dbo.stores (
    stor_id character(4) NOT NULL,
    stor_name character varying(80),
    stor_address character varying(80),
    city character varying(40),
    state character(2),
    zip character(5)
);
ALTER TABLE dbo.stores ADD CONSTRAINT upk_storeid PRIMARY KEY (stor_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.roysched...';END$$;
CREATE TABLE dbo.roysched (
    title_id character varying(6) NOT NULL,
    lorange integer,
    hirange integer,
    royalty integer
);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.publishers...';END$$;
CREATE TABLE dbo.publishers (
    pub_id character(8) NOT NULL,
    pub_name character varying(100),
    city character varying(100),
    state character(2),
    country character varying(80) DEFAULT 'USA'::character varying
);
ALTER TABLE dbo.publishers ADD CONSTRAINT upkcl_pubind PRIMARY KEY (pub_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.publication_types...';END$$;
CREATE TABLE dbo.publication_types (
    publication_type character varying(20) NOT NULL
);
ALTER TABLE dbo.publication_types ADD CONSTRAINT publication_types_pkey PRIMARY KEY (publication_type);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pub_info...';END$$;
CREATE TABLE dbo.pub_info (
    pub_id character(8) NOT NULL,
    logo bytea,
    pr_info text
);
ALTER TABLE dbo.pub_info ADD CONSTRAINT upkcl_pubinfo PRIMARY KEY (pub_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.jobs...';END$$;
CREATE TABLE dbo.jobs (
    job_id smallint NOT NULL GENERATED ALWAYS AS IDENTITY,
    job_desc character varying(50) NOT NULL DEFAULT 'New Position - title not formalized yet'::character varying,
    min_lvl smallint NOT NULL,
    max_lvl smallint NOT NULL
);
ALTER TABLE dbo.jobs ADD CONSTRAINT pk__jobs PRIMARY KEY (job_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.flyway_schema_history...';END$$;
CREATE TABLE dbo.flyway_schema_history (
    installed_rank integer NOT NULL,
    version character varying(50),
    description character varying(200) NOT NULL,
    type character varying(20) NOT NULL,
    script character varying(1000) NOT NULL,
    checksum integer,
    installed_by character varying(100) NOT NULL,
    installed_on timestamp without time zone NOT NULL DEFAULT now(),
    execution_time integer NOT NULL,
    success boolean NOT NULL
);
ALTER TABLE dbo.flyway_schema_history ADD CONSTRAINT flyway_schema_history_pk PRIMARY KEY (installed_rank);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.discounts...';END$$;
CREATE TABLE dbo.discounts (
    discounttype character varying(80) NOT NULL,
    stor_id character(4),
    lowqty smallint,
    highqty smallint,
    discount numeric(4,2) NOT NULL,
    discount_id integer NOT NULL GENERATED BY DEFAULT AS IDENTITY
);
ALTER TABLE dbo.discounts ADD CONSTRAINT discounts_pkey PRIMARY KEY (discount_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.splitstringtowords(text)...';END$$;
CREATE FUNCTION dbo.splitstringtowords(IN thestring text)
RETURNS TABLE(theorder integer, theword character varying)
LANGUAGE plpgsql
AS $_$
BEGIN
	CREATE TEMPORARY TABLE Words(TheOrder int GENERATED always AS IDENTITY , TheWord VARCHAR(50));
	insert into words(TheWord) Select REGEXP_MATCHES(TheString, '\w+' ,'g') as TheWords;
    RETURN QUERY
    SELECT Words.TheOrder,  trim(Both '{}' from words.theword)::varchar(50)
    FROM Words;
    Drop table words;
END
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.reptq3(money, money, character)...';END$$;
CREATE PROCEDURE dbo.reptq3(IN lolimit money, IN hilimit money, IN type character)
LANGUAGE sql
AS $_$
select 
	case when grouping(pub_id) = 1 then 'ALL' else pub_id end as pub_id, 
	case when grouping(type) = 1 then 'ALL' else type end as type, 
	count(title_id) as cnt
from titles
where price > lolimit AND price < hilimit AND type =  type OR type LIKE '%cook%'
  GROUP BY pub_id, type
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.reptq2()...';END$$;
CREATE PROCEDURE dbo.reptq2()
LANGUAGE sql
AS $_$
SELECT CASE WHEN Grouping(type) = 1 THEN 'ALL' ELSE type END AS type,
  CASE WHEN Grouping(pub_id) = 1 THEN 'ALL' ELSE pub_id END AS pub_id,
  avg(ytd_sales) AS avg_ytd_sales
  FROM titles
  WHERE pub_id IS NOT NULL
  GROUP BY pub_id, type 
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.reptq1()...';END$$;
CREATE PROCEDURE dbo.reptq1()
LANGUAGE sql
AS $_$
select 
	case when grouping(pub_id) = 1 then 'ALL' else pub_id end as pub_id, 
	avg(price) as avg_price
from titles
where price is NOT NULL
group by pub_id 
order by pub_id
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.byroyalty(integer)...';END$$;
CREATE PROCEDURE dbo.byroyalty(IN percentage integer)
LANGUAGE sql
AS $_$
select au_id from titleauthor
where titleauthor.royaltyper = percentage
$_$;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.tagtitle.tagtitle_tagname_id_fkey...';END$$;
ALTER TABLE dbo.tagtitle ADD CONSTRAINT tagtitle_tagname_id_fkey FOREIGN KEY (tagname_id) REFERENCES dbo.tagname (tagname_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pub_info.fk__pub_info__pub_id...';END$$;
ALTER TABLE dbo.pub_info ADD CONSTRAINT fk__pub_info__pub_id FOREIGN KEY (pub_id) REFERENCES dbo.publishers (pub_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.titleid_index...';END$$;
CREATE INDEX titleid_index ON dbo.tagtitle USING btree (title_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.tagname_index...';END$$;
CREATE INDEX tagname_index ON dbo.tagtitle USING btree (tagname_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.tagname_tag_key...';END$$;
ALTER TABLE dbo.tagname ADD CONSTRAINT tagname_tag_key UNIQUE (tag);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pk_stores_idx...';END$$;
CREATE UNIQUE INDEX pk_stores_idx ON dbo.stores USING btree (stor_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.discounts.fk__discounts__stor...';END$$;
ALTER TABLE dbo.discounts ADD CONSTRAINT fk__discounts__stor FOREIGN KEY (stor_id) REFERENCES dbo.stores (stor_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pk_pub_idx...';END$$;
CREATE INDEX pk_pub_idx ON dbo.publishers USING btree (pub_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pk_pub_info_idx...';END$$;
CREATE INDEX pk_pub_info_idx ON dbo.pub_info USING btree (pub_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pk__idx...';END$$;
CREATE INDEX pk__idx ON dbo.jobs USING btree (job_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.flyway_schema_history_s_idx...';END$$;
CREATE INDEX flyway_schema_history_s_idx ON dbo.flyway_schema_history USING btree (success);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.storid_index...';END$$;
CREATE INDEX storid_index ON dbo.discounts USING btree (stor_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pk_discounts_idx...';END$$;
CREATE INDEX pk_discounts_idx ON dbo.discounts USING btree (discount_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.tid...';END$$;
CREATE DOMAIN dbo.tid AS character varying(6);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.titleauthor...';END$$;
CREATE TABLE dbo.titleauthor (
    au_id character varying(11) NOT NULL,
    title_id dbo.tid NOT NULL,
    au_ord integer,
    royaltyper integer
);
ALTER TABLE dbo.titleauthor ADD CONSTRAINT newtitleauthor_pkey PRIMARY KEY (au_id, title_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.sales...';END$$;
CREATE TABLE dbo.sales (
    stor_id character(4) NOT NULL,
    ord_num character varying(20) NOT NULL,
    ord_date date NOT NULL,
    qty integer NOT NULL,
    payterms character varying(12) NOT NULL,
    title_id dbo.tid NOT NULL
);
ALTER TABLE dbo.sales ADD CONSTRAINT newsales_pkey PRIMARY KEY (ord_num, stor_id, title_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.sales.newsales_stor_id_fkey...';END$$;
ALTER TABLE dbo.sales ADD CONSTRAINT newsales_stor_id_fkey FOREIGN KEY (stor_id) REFERENCES dbo.stores (stor_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.publications...';END$$;
CREATE TABLE dbo.publications (
    publication_id dbo.tid NOT NULL,
    title character varying(255) NOT NULL,
    pub_id dbo.tid,
    notes character varying(4000),
    pubdate date NOT NULL DEFAULT CURRENT_DATE
);
ALTER TABLE dbo.publications ADD CONSTRAINT publications_pkey PRIMARY KEY (publication_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.titleauthor.newtitleauthor_title_id_fkey...';END$$;
ALTER TABLE dbo.titleauthor ADD CONSTRAINT newtitleauthor_title_id_fkey FOREIGN KEY (title_id) REFERENCES dbo.publications (publication_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.tagtitle.tagtitle_title_id_fkey...';END$$;
ALTER TABLE dbo.tagtitle ADD CONSTRAINT tagtitle_title_id_fkey FOREIGN KEY (title_id) REFERENCES dbo.publications (publication_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.sales.newsales_title_id_fkey...';END$$;
ALTER TABLE dbo.sales ADD CONSTRAINT newsales_title_id_fkey FOREIGN KEY (title_id) REFERENCES dbo.publications (publication_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.roysched.newroysched_title_id_fkey...';END$$;
ALTER TABLE dbo.roysched ADD CONSTRAINT newroysched_title_id_fkey FOREIGN KEY (title_id) REFERENCES dbo.publications (publication_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pubid_index...';END$$;
CREATE INDEX pubid_index ON dbo.publications USING btree (pub_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.editions...';END$$;
CREATE TABLE dbo.editions (
    edition_id integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    publication_id dbo.tid NOT NULL,
    publication_type character varying(20) NOT NULL DEFAULT 'book'::character varying,
    editiondate date NOT NULL DEFAULT CURRENT_DATE
);
ALTER TABLE dbo.editions ADD CONSTRAINT editions_pkey PRIMARY KEY (edition_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.editions.fk_publication_type...';END$$;
ALTER TABLE dbo.editions ADD CONSTRAINT fk_publication_type FOREIGN KEY (publication_type) REFERENCES dbo.publication_types (publication_type);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.publicationid_index...';END$$;
CREATE INDEX publicationid_index ON dbo.editions USING btree (publication_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.id...';END$$;
CREATE DOMAIN dbo.id AS character varying(11);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.authors...';END$$;
CREATE TABLE dbo.authors (
    au_id dbo.id NOT NULL,
    au_lname character varying(80) NOT NULL,
    au_fname character varying(80) NOT NULL,
    phone character varying(40) NOT NULL DEFAULT 'UNKNOWN'::character varying,
    address character varying(80),
    city character varying(40),
    state character(2),
    zip character(5),
    contract bit(1) NOT NULL
);
ALTER TABLE dbo.authors ADD CONSTRAINT upkcl_auidind PRIMARY KEY (au_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.titleauthor.newtitleauthor_au_id_fkey...';END$$;
ALTER TABLE dbo.titleauthor ADD CONSTRAINT newtitleauthor_au_id_fkey FOREIGN KEY (au_id) REFERENCES dbo.authors (au_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pk_authors_idx...';END$$;
CREATE INDEX pk_authors_idx ON dbo.authors USING btree (au_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.aunmind...';END$$;
CREATE INDEX aunmind ON dbo.authors USING btree (au_lname, au_fname);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.empid...';END$$;
CREATE DOMAIN dbo.empid AS character(9);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.employee...';END$$;
CREATE TABLE dbo.employee (
    emp_id dbo.empid NOT NULL,
    fname character varying(40) NOT NULL,
    minit character(1),
    lname character varying(60) NOT NULL,
    job_id smallint NOT NULL DEFAULT 1,
    job_lvl smallint DEFAULT 10,
    pub_id character(8) NOT NULL DEFAULT '9952'::bpchar,
    hire_date date NOT NULL DEFAULT CURRENT_DATE
);
ALTER TABLE dbo.employee ADD CONSTRAINT pk_emp_id PRIMARY KEY (emp_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.employee.fk__employee__pub_id...';END$$;
ALTER TABLE dbo.employee ADD CONSTRAINT fk__employee__pub_id FOREIGN KEY (pub_id) REFERENCES dbo.publishers (pub_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.employee.fk__employee__job_id...';END$$;
ALTER TABLE dbo.employee ADD CONSTRAINT fk__employee__job_id FOREIGN KEY (job_id) REFERENCES dbo.jobs (job_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.pub_id_index...';END$$;
CREATE INDEX pub_id_index ON dbo.employee USING btree (pub_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.jobid_index...';END$$;
CREATE INDEX jobid_index ON dbo.employee USING btree (job_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.employee_ind...';END$$;
CREATE INDEX employee_ind ON dbo.employee USING btree (lname, fname, minit);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.dollars...';END$$;
CREATE DOMAIN dbo.dollars AS numeric(9,2);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.prices...';END$$;
CREATE TABLE dbo.prices (
    price_id integer NOT NULL GENERATED ALWAYS AS IDENTITY,
    edition_id integer,
    price dbo.dollars,
    advance dbo.dollars,
    royalty integer,
    ytd_sales integer,
    pricestartdate date NOT NULL DEFAULT CURRENT_DATE,
    priceenddate date
);
ALTER TABLE dbo.prices ADD CONSTRAINT prices_pkey PRIMARY KEY (price_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.titlesandeditionsbypublisher...';END$$;
CREATE VIEW dbo.titlesandeditionsbypublisher (publisher, title, listofeditions) AS SELECT publishers.pub_name AS publisher,
    publications.title,
    string_agg(concat(editions.publication_type, ' ($', prices.price, ')'), ','::text) AS listofeditions
   FROM (((dbo.editions
     JOIN dbo.prices ON ((prices.edition_id = editions.edition_id)))
     JOIN dbo.publications ON (((publications.publication_id)::text = (editions.publication_id)::text)))
     JOIN dbo.publishers ON (((publications.pub_id)::bpchar = publishers.pub_id)))
  WHERE (prices.priceenddate IS NULL)
  GROUP BY publishers.pub_name, publications.title;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.titles...';END$$;
CREATE VIEW dbo.titles (title_id, title, type, pub_id, price, advance, royalty, ytd_sales, notes, pubdate) AS SELECT publications.publication_id AS title_id,
    publications.title,
    tagname.tag AS type,
    publications.pub_id,
    prices.price,
    prices.advance,
    prices.royalty,
    prices.ytd_sales,
    publications.notes,
    publications.pubdate
   FROM ((((dbo.publications
     JOIN dbo.editions ON ((((editions.publication_id)::text = (publications.publication_id)::text) AND ((editions.publication_type)::text = 'book'::text))))
     JOIN dbo.prices ON ((prices.edition_id = editions.edition_id)))
     LEFT JOIN dbo.tagtitle ON ((((tagtitle.title_id)::text = (publications.publication_id)::text) AND (tagtitle.is_primary = 1))))
     LEFT JOIN dbo.tagname ON ((tagtitle.tagname_id = tagname.tagname_id)))
  WHERE (prices.priceenddate IS NULL);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.titleview...';END$$;
CREATE VIEW dbo.titleview (title, au_ord, au_lname, price, ytd_sales, pub_id) AS SELECT titles.title,
    titleauthor.au_ord,
    authors.au_lname,
    titles.price,
    titles.ytd_sales,
    titles.pub_id
   FROM ((dbo.titleauthor
     JOIN dbo.titles ON (((titles.title_id)::text = (titleauthor.title_id)::text)))
     JOIN dbo.authors ON (((authors.au_id)::text = (titleauthor.au_id)::text)));


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating dbo.editionid_index...';END$$;
CREATE INDEX editionid_index ON dbo.prices USING btree (edition_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting...';END$$;
CREATE SCHEMA accounting;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.suppliers...';END$$;
CREATE TABLE accounting.suppliers (
    id integer NOT NULL,
    supplier_id integer,
    contact_id integer,
    customerfrom date NOT NULL,
    customerto date,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE accounting.suppliers ADD CONSTRAINT suppliers_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.spent_moneys...';END$$;
CREATE TABLE accounting.spent_moneys (
    id integer NOT NULL,
    tran_date date NOT NULL,
    description text,
    reference text,
    total numeric(20,2) NOT NULL,
    supplier_id integer,
    chart_of_accounts_id integer NOT NULL
);
ALTER TABLE accounting.spent_moneys ADD CONSTRAINT spent_moneys_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.spent_money_lines...';END$$;
CREATE TABLE accounting.spent_money_lines (
    id integer NOT NULL,
    line_amount numeric(20,2) NOT NULL,
    spent_money_id integer,
    line_chart_of_accounts_id integer NOT NULL
);
ALTER TABLE accounting.spent_money_lines ADD CONSTRAINT spent_money_lines_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.received_moneys...';END$$;
CREATE TABLE accounting.received_moneys (
    id integer NOT NULL,
    tran_date date NOT NULL,
    description text,
    reference text,
    total numeric(20,2) NOT NULL,
    customer_id integer NOT NULL,
    chart_of_accounts_id integer NOT NULL
);
ALTER TABLE accounting.received_moneys ADD CONSTRAINT received_moneys_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.received_money_lines...';END$$;
CREATE TABLE accounting.received_money_lines (
    id integer NOT NULL,
    line_amount numeric(20,2) NOT NULL,
    received_money_id integer,
    line_chart_of_accounts_id integer NOT NULL
);
ALTER TABLE accounting.received_money_lines ADD CONSTRAINT received_money_lines_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoices...';END$$;
CREATE TABLE accounting.invoices (
    id integer NOT NULL,
    tran_date date NOT NULL,
    due_date date,
    description text,
    reference text,
    total numeric(10,2) NOT NULL,
    status smallint,
    customer_id integer,
    invoice_payment_id integer,
    chart_of_accounts_id integer NOT NULL
);
ALTER TABLE accounting.invoices ADD CONSTRAINT invoices_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoice_payments...';END$$;
CREATE TABLE accounting.invoice_payments (
    id integer NOT NULL,
    tran_date date NOT NULL,
    description text NOT NULL,
    reference text NOT NULL,
    total numeric(20,2) NOT NULL,
    chart_of_accounts_id integer NOT NULL,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE accounting.invoice_payments ADD CONSTRAINT invoice_payments_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoice_lines...';END$$;
CREATE TABLE accounting.invoice_lines (
    id integer NOT NULL,
    line_amount numeric(20,2) NOT NULL,
    invoice_id integer,
    line_chart_of_accounts_id integer NOT NULL
);
ALTER TABLE accounting.invoice_lines ADD CONSTRAINT invoice_lines_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.customer...';END$$;
CREATE TABLE accounting.customer (
    id integer NOT NULL,
    person_id integer,
    organisation_id integer,
    customerfrom date NOT NULL,
    customerto date,
    modifieddate timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE accounting.customer ADD CONSTRAINT customer_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.chart_of_accounts...';END$$;
CREATE TABLE accounting.chart_of_accounts (
    id integer NOT NULL,
    name character varying(50)
);
ALTER TABLE accounting.chart_of_accounts ADD CONSTRAINT chart_of_accounts_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bills...';END$$;
CREATE TABLE accounting.bills (
    id integer NOT NULL,
    tran_date date NOT NULL,
    due_date date,
    description text,
    reference text,
    total numeric(10,2) NOT NULL,
    status smallint,
    supplier_id integer,
    bill_payment_id integer,
    chart_of_accounts_id integer NOT NULL
);
ALTER TABLE accounting.bills ADD CONSTRAINT bills_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bill_payments...';END$$;
CREATE TABLE accounting.bill_payments (
    id integer NOT NULL,
    tran_date date NOT NULL,
    description text,
    reference text,
    total numeric(20,2) NOT NULL,
    chart_of_accounts_id integer NOT NULL
);
ALTER TABLE accounting.bill_payments ADD CONSTRAINT bill_payments_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bill_lines...';END$$;
CREATE TABLE accounting.bill_lines (
    id integer NOT NULL,
    line_amount numeric(20,2) NOT NULL,
    bill_id integer,
    line_chart_of_accounts_id integer NOT NULL
);
ALTER TABLE accounting.bill_lines ADD CONSTRAINT bill_lines_pkey PRIMARY KEY (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.spent_money_trans...';END$$;
CREATE VIEW accounting.spent_money_trans (tran_id, tran_date, chart_of_accounts_id, chart_of_accounts_name, total, line_id, line_chart_of_accounts_id, line_chart_of_accounts_name, line_amount) AS SELECT ('SM'::text || ((sm.id)::character varying(10))::text) AS tran_id,
    sm.tran_date,
    sm.chart_of_accounts_id,
    'Business Bank Account'::text AS chart_of_accounts_name,
    sm.total,
    sml.id AS line_id,
    sml.line_chart_of_accounts_id,
    c.name AS line_chart_of_accounts_name,
    sml.line_amount
   FROM ((accounting.spent_moneys sm
     LEFT JOIN accounting.spent_money_lines sml ON ((sm.id = sml.spent_money_id)))
     LEFT JOIN accounting.chart_of_accounts c ON ((c.id = sml.line_chart_of_accounts_id)));


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.received_money_trans...';END$$;
CREATE VIEW accounting.received_money_trans (tran_id, tran_date, chart_of_accounts_id, chart_of_accounts_name, total, line_id, line_chart_of_accounts_id, line_chart_of_accounts_name, line_amount) AS SELECT ('RM'::text || ((rm.id)::character varying(10))::text) AS tran_id,
    rm.tran_date,
    rm.chart_of_accounts_id,
    'Business Bank Account'::text AS chart_of_accounts_name,
    rm.total,
    rml.id AS line_id,
    rml.line_chart_of_accounts_id,
    c.name AS line_chart_of_accounts_name,
    rml.line_amount
   FROM ((accounting.received_moneys rm
     LEFT JOIN accounting.received_money_lines rml ON ((rm.id = rml.received_money_id)))
     LEFT JOIN accounting.chart_of_accounts c ON ((c.id = rml.line_chart_of_accounts_id)));


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoice_trans...';END$$;
CREATE VIEW accounting.invoice_trans (tran_id, tran_date, ar_account, name, total, line_id, line_chart_of_accounts_id, line_amount, id, bank_account, bank_name, status, line_chart_of_accounts_name) AS WITH itrans AS (
         SELECT (i.id)::character varying(10) AS tran_id,
            i.tran_date,
            i.chart_of_accounts_id AS ar_account,
            c_1.name,
            i.total,
            il.id AS line_id,
            il.line_chart_of_accounts_id,
            il.line_amount,
            ip.id,
            ip.chart_of_accounts_id AS bank_account,
            'Business Bank account'::text AS bank_name,
            i.status
           FROM (((accounting.invoices i
             LEFT JOIN accounting.invoice_lines il ON ((i.id = il.invoice_id)))
             LEFT JOIN accounting.chart_of_accounts c_1 ON ((i.chart_of_accounts_id = c_1.id)))
             LEFT JOIN accounting.invoice_payments ip ON ((i.invoice_payment_id = ip.id)))
        )
 SELECT itrans.tran_id,
    itrans.tran_date,
    itrans.ar_account,
    itrans.name,
    itrans.total,
    itrans.line_id,
    itrans.line_chart_of_accounts_id,
    itrans.line_amount,
    itrans.id,
    itrans.bank_account,
    itrans.bank_name,
    itrans.status,
    c.name AS line_chart_of_accounts_name
   FROM (itrans
     LEFT JOIN accounting.chart_of_accounts c ON ((itrans.line_chart_of_accounts_id = c.id)));


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bill_trans...';END$$;
CREATE VIEW accounting.bill_trans (tran_id, tran_date, ap_account, name, total, line_id, line_chart_of_accounts_id, line_amount, id, bank_account, bank_name, status, line_chart_of_accounts_name) AS WITH btrans AS (
         SELECT (b.id)::character varying(10) AS tran_id,
            b.tran_date,
            b.chart_of_accounts_id AS ap_account,
            c_1.name,
            b.total,
            bl.id AS line_id,
            bl.line_chart_of_accounts_id,
            bl.line_amount,
            bp.id,
            bp.chart_of_accounts_id AS bank_account,
            'Business Bank Account'::text AS bank_name,
            b.status
           FROM (((accounting.bills b
             LEFT JOIN accounting.bill_lines bl ON ((b.id = bl.bill_id)))
             LEFT JOIN accounting.chart_of_accounts c_1 ON ((b.chart_of_accounts_id = c_1.id)))
             LEFT JOIN accounting.bill_payments bp ON ((b.bill_payment_id = bp.id)))
        )
 SELECT btrans.tran_id,
    btrans.tran_date,
    btrans.ap_account,
    btrans.name,
    btrans.total,
    btrans.line_id,
    btrans.line_chart_of_accounts_id,
    btrans.line_amount,
    btrans.id,
    btrans.bank_account,
    btrans.bank_name,
    btrans.status,
    c.name AS line_chart_of_accounts_name
   FROM (btrans
     LEFT JOIN accounting.chart_of_accounts c ON ((btrans.line_chart_of_accounts_id = c.id)));


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.trial_balance...';END$$;
CREATE VIEW accounting.trial_balance (acct_code, acct_name, debit_bal, credit_bal) AS SELECT invoice_trans.line_chart_of_accounts_id AS acct_code,
    invoice_trans.line_chart_of_accounts_name AS acct_name,
        CASE
            WHEN (sum(invoice_trans.line_amount) > (0)::numeric) THEN sum(invoice_trans.line_amount)
            ELSE (0)::numeric
        END AS debit_bal,
        CASE
            WHEN (sum(invoice_trans.line_amount) < (0)::numeric) THEN sum(invoice_trans.line_amount)
            ELSE (0)::numeric
        END AS credit_bal
   FROM accounting.invoice_trans
  GROUP BY invoice_trans.line_chart_of_accounts_id, invoice_trans.line_chart_of_accounts_name
UNION ALL
 SELECT bill_trans.line_chart_of_accounts_id AS acct_code,
    bill_trans.line_chart_of_accounts_name AS acct_name,
        CASE
            WHEN (sum(bill_trans.line_amount) > (0)::numeric) THEN sum(bill_trans.line_amount)
            ELSE (0)::numeric
        END AS debit_bal,
        CASE
            WHEN (sum(bill_trans.line_amount) < (0)::numeric) THEN sum(bill_trans.line_amount)
            ELSE (0)::numeric
        END AS credit_bal
   FROM accounting.bill_trans
  GROUP BY bill_trans.line_chart_of_accounts_id, bill_trans.line_chart_of_accounts_name
UNION ALL
 SELECT received_money_trans.line_chart_of_accounts_id AS acct_code,
    received_money_trans.line_chart_of_accounts_name AS acct_name,
        CASE
            WHEN (sum(received_money_trans.line_amount) > (0)::numeric) THEN sum(received_money_trans.line_amount)
            ELSE (0)::numeric
        END AS debit_bal,
        CASE
            WHEN (sum(received_money_trans.line_amount) < (0)::numeric) THEN sum(received_money_trans.line_amount)
            ELSE (0)::numeric
        END AS credit_bal
   FROM accounting.received_money_trans
  GROUP BY received_money_trans.line_chart_of_accounts_id, received_money_trans.line_chart_of_accounts_name
UNION ALL
 SELECT spent_money_trans.line_chart_of_accounts_id AS acct_code,
    spent_money_trans.line_chart_of_accounts_name AS acct_name,
        CASE
            WHEN (sum(spent_money_trans.line_amount) > (0)::numeric) THEN sum(spent_money_trans.line_amount)
            ELSE (0)::numeric
        END AS debit_bal,
        CASE
            WHEN (sum(spent_money_trans.line_amount) < (0)::numeric) THEN sum(spent_money_trans.line_amount)
            ELSE (0)::numeric
        END AS credit_bal
   FROM accounting.spent_money_trans
  GROUP BY spent_money_trans.line_chart_of_accounts_id, spent_money_trans.line_chart_of_accounts_name
UNION ALL
 SELECT max(bill_trans.ap_account) AS acct_code,
    max((bill_trans.line_chart_of_accounts_name)::text) AS acct_name,
    (-
        CASE
            WHEN (sum(bill_trans.line_amount) < (0)::numeric) THEN sum(bill_trans.line_amount)
            ELSE (0)::numeric
        END) AS debit_bal,
    (-
        CASE
            WHEN (sum(bill_trans.line_amount) > (0)::numeric) THEN sum(bill_trans.line_amount)
            ELSE (0)::numeric
        END) AS credit_bal
   FROM accounting.bill_trans
  WHERE (bill_trans.status = 0)
UNION ALL
 SELECT max(invoice_trans.ar_account) AS acct_code,
    max((invoice_trans.line_chart_of_accounts_name)::text) AS acct_name,
    (-
        CASE
            WHEN (sum(invoice_trans.line_amount) < (0)::numeric) THEN sum(invoice_trans.line_amount)
            ELSE (0)::numeric
        END) AS debit_bal,
    (-
        CASE
            WHEN (sum(invoice_trans.line_amount) > (0)::numeric) THEN sum(invoice_trans.line_amount)
            ELSE (0)::numeric
        END) AS credit_bal
   FROM accounting.invoice_trans
  WHERE (invoice_trans.status = 0)
UNION ALL
 SELECT max(bill_trans.bank_account) AS acct_code,
    max(bill_trans.bank_name) AS acct_name,
    (-
        CASE
            WHEN (sum(bill_trans.line_amount) < (0)::numeric) THEN sum(bill_trans.line_amount)
            ELSE (0)::numeric
        END) AS debit_bal,
    (-
        CASE
            WHEN (sum(bill_trans.line_amount) > (0)::numeric) THEN sum(bill_trans.line_amount)
            ELSE (0)::numeric
        END) AS credit_bal
   FROM accounting.bill_trans
  WHERE (bill_trans.status = 1)
UNION ALL
 SELECT max(invoice_trans.bank_account) AS acct_code,
    max(invoice_trans.bank_name) AS acct_name,
    (-
        CASE
            WHEN (sum(invoice_trans.line_amount) < (0)::numeric) THEN sum(invoice_trans.line_amount)
            ELSE (0)::numeric
        END) AS debit_bal,
    (-
        CASE
            WHEN (sum(invoice_trans.line_amount) > (0)::numeric) THEN sum(invoice_trans.line_amount)
            ELSE (0)::numeric
        END) AS credit_bal
   FROM accounting.invoice_trans
  WHERE (invoice_trans.status = 1)
UNION ALL
 SELECT max(received_money_trans.chart_of_accounts_id) AS acct_code,
    max(received_money_trans.chart_of_accounts_name) AS acct_name,
    (-
        CASE
            WHEN (sum(received_money_trans.line_amount) < (0)::numeric) THEN sum(received_money_trans.line_amount)
            ELSE (0)::numeric
        END) AS debit_bal,
    (-
        CASE
            WHEN (sum(received_money_trans.line_amount) > (0)::numeric) THEN sum(received_money_trans.line_amount)
            ELSE (0)::numeric
        END) AS credit_bal
   FROM accounting.received_money_trans
UNION ALL
 SELECT max(spent_money_trans.chart_of_accounts_id) AS acct_code,
    max(spent_money_trans.chart_of_accounts_name) AS acct_name,
    (-
        CASE
            WHEN (sum(spent_money_trans.line_amount) < (0)::numeric) THEN sum(spent_money_trans.line_amount)
            ELSE (0)::numeric
        END) AS debit_bal,
    (-
        CASE
            WHEN (sum(spent_money_trans.line_amount) > (0)::numeric) THEN sum(spent_money_trans.line_amount)
            ELSE (0)::numeric
        END) AS credit_bal
   FROM accounting.spent_money_trans;


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.suppliers.fk_supplier_id_organisation_id...';END$$;
ALTER TABLE accounting.suppliers ADD CONSTRAINT fk_supplier_id_organisation_id FOREIGN KEY (supplier_id) REFERENCES people.organisation (organisation_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.suppliers.fk_contact_id_organisation_id...';END$$;
ALTER TABLE accounting.suppliers ADD CONSTRAINT fk_contact_id_organisation_id FOREIGN KEY (contact_id) REFERENCES people.organisation (organisation_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.spent_moneys.spent_moneys_supplier_id_fkey...';END$$;
ALTER TABLE accounting.spent_moneys ADD CONSTRAINT spent_moneys_supplier_id_fkey FOREIGN KEY (supplier_id) REFERENCES accounting.suppliers (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.spent_moneys.spent_moneys_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.spent_moneys ADD CONSTRAINT spent_moneys_chart_of_accounts_id_fkey FOREIGN KEY (chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.spent_money_lines.spent_money_lines_spent_money_id_fkey...';END$$;
ALTER TABLE accounting.spent_money_lines ADD CONSTRAINT spent_money_lines_spent_money_id_fkey FOREIGN KEY (spent_money_id) REFERENCES accounting.spent_moneys (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.spent_money_lines.spent_money_lines_line_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.spent_money_lines ADD CONSTRAINT spent_money_lines_line_chart_of_accounts_id_fkey FOREIGN KEY (line_chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.received_moneys.received_moneys_customer_id_fkey...';END$$;
ALTER TABLE accounting.received_moneys ADD CONSTRAINT received_moneys_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES accounting.customer (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.received_moneys.received_moneys_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.received_moneys ADD CONSTRAINT received_moneys_chart_of_accounts_id_fkey FOREIGN KEY (chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.received_money_lines.received_money_lines_received_money_id_fkey...';END$$;
ALTER TABLE accounting.received_money_lines ADD CONSTRAINT received_money_lines_received_money_id_fkey FOREIGN KEY (received_money_id) REFERENCES accounting.received_moneys (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.received_money_lines.received_money_lines_line_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.received_money_lines ADD CONSTRAINT received_money_lines_line_chart_of_accounts_id_fkey FOREIGN KEY (line_chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoices.invoices_invoice_payment_id_fkey...';END$$;
ALTER TABLE accounting.invoices ADD CONSTRAINT invoices_invoice_payment_id_fkey FOREIGN KEY (invoice_payment_id) REFERENCES accounting.invoice_payments (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoices.invoices_customer_id_fkey...';END$$;
ALTER TABLE accounting.invoices ADD CONSTRAINT invoices_customer_id_fkey FOREIGN KEY (customer_id) REFERENCES accounting.customer (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoices.invoices_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.invoices ADD CONSTRAINT invoices_chart_of_accounts_id_fkey FOREIGN KEY (chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoice_payments.invoice_payments_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.invoice_payments ADD CONSTRAINT invoice_payments_chart_of_accounts_id_fkey FOREIGN KEY (chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoice_lines.invoice_lines_line_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.invoice_lines ADD CONSTRAINT invoice_lines_line_chart_of_accounts_id_fkey FOREIGN KEY (line_chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.invoice_lines.invoice_lines_invoice_id_fkey...';END$$;
ALTER TABLE accounting.invoice_lines ADD CONSTRAINT invoice_lines_invoice_id_fkey FOREIGN KEY (invoice_id) REFERENCES accounting.invoices (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.customer.fk_person_id_person_id...';END$$;
ALTER TABLE accounting.customer ADD CONSTRAINT fk_person_id_person_id FOREIGN KEY (person_id) REFERENCES people.person (person_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.customer.fk_organisation_id_organisation_id...';END$$;
ALTER TABLE accounting.customer ADD CONSTRAINT fk_organisation_id_organisation_id FOREIGN KEY (organisation_id) REFERENCES people.organisation (organisation_id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bills.bills_supplier_id_fkey...';END$$;
ALTER TABLE accounting.bills ADD CONSTRAINT bills_supplier_id_fkey FOREIGN KEY (supplier_id) REFERENCES accounting.suppliers (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bills.bills_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.bills ADD CONSTRAINT bills_chart_of_accounts_id_fkey FOREIGN KEY (chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bills.bills_bill_payment_id_fkey...';END$$;
ALTER TABLE accounting.bills ADD CONSTRAINT bills_bill_payment_id_fkey FOREIGN KEY (bill_payment_id) REFERENCES accounting.bill_payments (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bill_payments.bill_payments_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.bill_payments ADD CONSTRAINT bill_payments_chart_of_accounts_id_fkey FOREIGN KEY (chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bill_lines.bill_lines_line_chart_of_accounts_id_fkey...';END$$;
ALTER TABLE accounting.bill_lines ADD CONSTRAINT bill_lines_line_chart_of_accounts_id_fkey FOREIGN KEY (line_chart_of_accounts_id) REFERENCES accounting.chart_of_accounts (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.bill_lines.bill_lines_bill_id_fkey...';END$$;
ALTER TABLE accounting.bill_lines ADD CONSTRAINT bill_lines_bill_id_fkey FOREIGN KEY (bill_id) REFERENCES accounting.bills (id);


DO language plpgsql $$BEGIN RAISE NOTICE 'Creating accounting.chart_of_accounts_name_key...';END$$;
ALTER TABLE accounting.chart_of_accounts ADD CONSTRAINT chart_of_accounts_name_key UNIQUE (name);

SET check_function_bodies = true;
