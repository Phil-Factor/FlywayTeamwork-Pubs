{
    "columns":  [
                    " nvarchar(MAX)",
                    "@JsonData nvarchar(MAX)",
                    "@Reference nvarchar(100)",
                    "@level int"
                ],
    "Definition":  "Create   function [dbo].[SentenceFrom] (\r\n @JsonData NVARCHAR(MAX), --the collection of objects, each one\r\n -- consisting of arrays of strings. If a word is prepended by  a \r\n -- ^ character, it is the name of the object whose value is the array \r\n -- of strings\r\n @Reference NVARCHAR(100), --the JSON reference to the object containing the\r\n -- list of strings to choose one item from.\r\n @level INT = 5--the depth of recursion allowed . 0 means don\u0027t recurse.\r\n ) \r\n/**\r\nSummary: \u003e \r\n   this function takes a json document that describes all the\r\n   alternative components\r\n   of a string and from it, it returns a string.\r\n   basically, you give it a list of alternatives and it selects one of them. However\r\n   if you put in the name of an array as one of the alternatives,rather than a word,\r\n   it will, if it selects it, treat it as a new reference and will select one of \r\n   these alternatives.\r\nAuthor: PhilFactor\r\nDate: 05/11/2020\r\nDatabase: PhilsScripts\r\nExamples:\r\n   - select dbo.SentenceFrom(\u0027{\r\n     \"name\":[ \"^prefix ^firstname ^lastname ^suffix\",\r\n\t   \"^prefix ^firstname ^lastname\",\"^firstname ^lastname\"\r\n      ],\r\n      \"prefix\":[\"Mr\",\"Mrs\",\"Miss\",\"Sir\",\"Dr\",\"professor\"\r\n      ],\r\n      \"firstname\":[\"Dick\",\"Bob\",\"Ravi\",\"Jess\",\"Karen\"\r\n      ],\r\n      \"lastname\":[\"Stevens\",\"Payne\",\"Boyd\",\"Sims\",\"Brown\"\r\n      ],\r\n      \"suffix\":[\"3rd\",\"MA\",\"BSc\",\"\",\"\",\"\",\"\",\"\"\r\n      ]\r\n    }\r\n    \u0027,\u0027$.name\u0027,5)\r\nReturns: \u003e\r\n  a randomised string.\r\n**/\r\n\r\nRETURNS NVARCHAR(MAX)\r\nAS\r\n  BEGIN\r\n    IF coalesce(@level,-1) \u003c 0 RETURN \u0027too many levels\u0027; /* if there is mutual \r\nreferences, this can potentially lead to a deadly embrace. This checks for that */\r\n    IF IsJson(@JsonData) \u003c\u003e 0 --check that the data is valid\r\n      BEGIN\r\n        DECLARE @Choices TABLE ([KEY] INT, value NVARCHAR(MAX));\r\n        DECLARE @words TABLE ([KEY] INT, value NVARCHAR(MAX));\r\n        DECLARE @ii INT, @iiMax INT, @Output NVARCHAR(MAX);\r\n        DECLARE @Endpunctuation VARCHAR(80); -- used to ensure we don\u0027t lose end punctuation\r\n        DECLARE @SingleWord NVARCHAR(800), @ValidJsonList NVARCHAR(800);\r\n\t\t--we check for a missing or global reference and use the first object\r\n        IF coalesce(@Reference,\u0027$\u0027) = \u0027$\u0027 \r\n\t\t   SELECT top 1 @Reference = \u0027$.\u0027+[key] --just get the first\r\n\t\t     FROM OpenJson(@JSONData ,\u0027$\u0027) where type=4;\r\n        insert into @choices ([key],Value) --put the choices in a temp table\r\n          SELECT [key],value FROM OpenJson(@JSONData ,@reference) where type=1\r\n\t\t-- if there was an easy way of getting the length of the array then we\r\n\t\t--could use JSON_VALUE ( expression , path ) to get the element   \r\n        -- and get the chosen string\r\n\t\tDECLARE @string NVARCHAR(4000) =\r\n           (SELECT TOP 1 value FROM @Choices \r\n\t\t     CROSS JOIN RAN ORDER BY RAN.number);\r\n        SELECT @ValidJsonList = N\u0027[\"\u0027 + Replace(string_escape(@string,\u0027json\u0027), \u0027 \u0027, \u0027\",\"\u0027) + N\u0027\"]\u0027;\r\n        IF IsJson(@ValidJsonList) = 0 RETURN N\u0027invalid reference- \u0027\r\n                                             + @ValidJsonList;\r\n        --now we examine each word in the string to see if it is reference\r\n\t\t--to another array within the JSON.\r\n\t\tINSERT INTO @words ([KEY], value)\r\n\t\t  SELECT [KEY], value\r\n\t\t\tFROM OpenJson( @ValidJsonList,\u0027$\u0027);\r\n        IF @@RowCount = 0 RETURN @ValidJsonList + \u0027 returned no words\u0027;\r\n        SELECT @ii = 0, @iiMax = Max([KEY]) FROM @words;\r\n\t\t-- we now loop through the words either treating the words as strings\r\n\t\t-- or symbols representing arrays\r\n        WHILE (@ii \u003c (@iiMax + 1))\r\n          BEGIN\r\n            SELECT @SingleWord = value FROM @words WHERE [KEY] = @ii;\r\n            IF @@RowCount = 0\r\n              BEGIN\r\n                SELECT @Output =\r\n                N\u0027no words in\u0027 + N\u0027[\"\u0027 + Replace(@string, \u0027 \u0027, \u0027\",\"\u0027) + N\u0027\"]\u0027;\r\n                RETURN @Output;\r\n              END;\r\n            SELECT @ii = @ii + 1;\r\n            IF Left(LTrim(@SingleWord), 1) = \u0027^\u0027-- it is a reference\r\n              BEGIN -- nick out the \u0027^\u0027 symbol\r\n                SELECT @Reference = \u0027$.\u0027 + Stuff(@SingleWord, 1, 1, \u0027\u0027),\r\n                @Endpunctuation = \u0027\u0027;\r\n                WHILE Reverse(@Reference) LIKE \u0027[:;.,-_()]%\u0027\r\n                  BEGIN --rescue any punctuation after the symbol\r\n                    DECLARE @End INT = Len(@Reference);\r\n                    SELECT @Endpunctuation = Substring(@Reference, @End, 1);\r\n                    SELECT @Reference = Substring(@Reference, 1, @End - 1);\r\n                  END; --and we call it recursively\r\n                IF @level \u003e 0\r\n                  SELECT @Output =\r\n                    Coalesce(@Output + \u0027 \u0027, \u0027\u0027)\r\n                    + dbo.SentenceFrom(@JsonData, @Reference, @level - 1)\r\n                    + @Endpunctuation;\r\n              END;\r\n            -- otherwise it is plain sailing. Would that it were always\r\n\t\t\t-- that simple\r\n            ELSE SELECT @Output = Coalesce(@Output + \u0027 \u0027, \u0027\u0027) + @SingleWord;\r\n          END;\r\n      END;\r\n    ELSE SELECT @Output = \u0027sorry. Error in the JSON\u0027;\r\n    RETURN @Output; --and return whatever (it could be a novel!)\r\n  END;",
    "documentation":  ""
}
